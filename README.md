# Транслятор
Данные проект представляет собой транслятор для программ [виртуальной машины](https://github.com/maks1596/VirtualMachine).

В качестве входных аргументов программа принимает:
- Имя транслируемого файла;
- (опционально) Имя выходного файла с бинарным кодом.

В результате выполнения программы генерируются два файла:
- [Файл листинга](#формат-файла-с-листингом);
- Двоичный файл с оттрансированной программой для [виртуальной машины](https://github.com/maks1596/VirtualMachine).

## Язык ассемблера
Транслятор ставит в соответствие строкам языка ассемблера коды виртуальной машины. Транслятор генерирует коды для перемещающего загрузчика, что означает, что оттранслированная последовательность байт может быть записана в память виртуальной машины в произвольное место с учётом сохранения последовательности байт. Формат строки языка ассемблера в [Расширенной Форме Бекуса-Наура (РБНФ)](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0) имеет следующий вид:  
```
[метка:] [ код [аргумент {, аргумент}] ] [//комментарий]
```

***Метка*** - это идентификатор, начинающейся с буквы латинского алфавита или символа ‘_’ и содержащей буквы латинского алфавита, символы ‘_’ или цифры. Метка может быть относительной или абсолютной. Все метки, объявленные вне директивы equ являются относительными. Далее приведён формат записи в таблице имён. 
```
Имя метки | Значение метки| Тип метки (относительная или абсолютная)
```

***Код*** - это слово, обозначающее определённую операцию виртуальной машины или директиву транслятора. Для слов, обозначающих операции виртуальной машины, создан словарь соответствий, подобный таблице 1.2.

***Аргумент*** - это идентификатор или константа, использование которых зависит от типа команды. Для каждой из директив аргумент используется по-своему.

### Директива определения данных
Директива определения данных может быть вызвана, если в качестве кода получены слова *«int»* или *«float»*. В качестве аргумента команда получает число.

*Целое число* в форме РБНФ имеет вид:
- бинарный формат: 0b<цифра>{<цифра>}
- 10-ричный формат: [+|-]<цифра>{<цифра>}
- 16-ричный формат: 0x<цифра>{<цифра>}

*Вещественное число* в форме РБНФ имеет вид:
```
[+|-]{<цифра>}[.]<цифра>{<цифра>}[(e|E)[+|-]<цифра>{<цифра>}]
```

### Директива Equ
Директива Equ определяет абсолютную метку в строке с данной директивой, что даёт возможность использовать её в некоторых командах и арифметических операциях. Аргумент, представленный в виде арифметического выражения используется как значение для задаваемой метки.
Формат директивы Equ имеет следующий вид:
```
метка: equ арифметическое_выражение [//комментарий]
```
Формат арифметического выражения в РБНФ:
```
A ::= +E | -E | E
E ::= T {+T|-T}
T ::= F{*F|/F|%F}
F ::=  const | name | (A)
```

### Директива End
Директива End является последней исполняемой в программе и содержит в аргументе стартовый адрес исполнения программы. Аргумент после директивы End является арифметическим выражением.
Формат директивы End:
```
[метка:] end арифметическое_выражение [//комментарий]
```
## Технология обработки информации
Транслятор считывает ассемблерные строки из входного файла. Затем происходит первый проход, во время которого подсчитываются значения меток и адреса команд. После идёт второй проход, во время которого:
- команды транслятора транслируются в коды виртуальной машины;
- исполняются директивы;
- формируется листинг.

В случае, если во время двух проходов не было найдено ни одной ошибки, коды виртуальной машины записываются в выходной файл.

### Формат входного файла
Входной файл содержит в себе набор форматированных строк языка ассемблера.
Пример входного файла:
```
; Вычисление факториала

one: int 1
main:
in r0		; счётчик
mov one, r2	; факториал
mov one, r1	; загрузили единицу в регистр
while:
cmp r1, r0	; сравниваем счётчик с единицей
je finish	; если счётчик равен 1, то переходим к концу
mul r2, r0	; умножили факториал на значение счётчика
sub r0, r1	; уменьшили значение счётчика

jmp while
finish: out r2	; выводим факториал
end main
```

### Формат выходного файла
Выходной файл представляет собой файл с кодами виртуальной машины в бинарном виде. Формат файла:
1. `<a>` - тег адреса начала загрузки (8 бит).
2. `LA` - Адрес начала загрузки (16 бит).
3. `<s>` - тег адреса начала исполнения программы (8 бит).
4. `IP` - Адрес начала исполнения программы (16 бит).
5. Двоичный код (список двоичных команд):
    1.	`<k>` двоичная команда — 1 бит тег и 32 бита команда.

### Формат файла с листингом
Листинг сохраняется в текстовый файл. Листинг состоит из списка строк следующего формата:
```
Относительный адрес | Команда виртуальной машины | № | Метка: | Код_операции | аргументы | //Комментарий
```
В случае, если при трансляции были обнаружены ошибки, то запись ошибочной строки будет иметь следующий вид:
```
№ | Метка: | Код_операции | аргументы | //Комментарий
Список ошибок
```

Пример выходного файла листинга удачно оттранслированной программы:
```
0:             |  1 |                     ; Вычисление факториала
0:             |  2 |                     
0: i 1 1       |  3 |    one: int 1       
1:             |  4 |   main:             
1: k 20 0 0    |  5 |         in r0       ; счётчик
2: k 16 9 2 0  |  6 |         mov one, r2 ; факториал
3: k 16 9 1 0  |  7 |         mov one, r1 ; загрузили единицу в регистр
4:             |  8 |  while:             
4: k 17 0 1    |  9 |         cmp r1, r0  ; сравниваем счётчик с единицей
5: k 25 1 14 8 | 10 |         je finish   ; если счётчик равен 1, то переходим к концу
6: k 4 0 2     | 11 |         mul r2, r0  ; умножили факториал на значение счётчика
6: k 3 1 0     | 12 |         sub r0, r1  ; уменьшили значение счётчика
7:             | 13 |                     
7: k 24 1 14 4 | 14 |         jmp while   
8: k 21 2 0    | 15 | finish: out r2      ; выводим факториал
8: k 1 22 14   | 16 |         end main    
```